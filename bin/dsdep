#!/bin/bash
# =============================================================================
# dsdep - Data Science Deployment Tool
# Deploy Python projects with systemd hardening on Linux
# 
# Repository: https://github.com/ripiktech/ripik_ds_helper
# License: MIT
# =============================================================================

set -e

VERSION="1.0.0"
SCRIPT_NAME="dsdep"
LOG_PREFIX="[dsdep]"

# ANSI Colors for verbose output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Default paths
DEFAULT_REQUIREMENTS_URL="https://raw.githubusercontent.com/ripiktech/ripik_ds_helper/main/requirements.txt"
HARDENING_SCRIPT_URL="https://raw.githubusercontent.com/ripiktech/ripik_ds_helper/main/DsHelper/linux_hardening.py"
DEFAULT_INSTALL_DIR="/opt/dsdep-projects"
TEMPLATES_DIR="/usr/share/dsdep/templates"

# =============================================================================
# Helper Functions
# =============================================================================

log_info() {
    echo -e "${BLUE}${LOG_PREFIX}${NC} ${CYAN}[INFO]${NC} $1"
}

log_success() {
    echo -e "${BLUE}${LOG_PREFIX}${NC} ${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${BLUE}${LOG_PREFIX}${NC} ${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${BLUE}${LOG_PREFIX}${NC} ${RED}[ERROR]${NC} $1"
}

log_step() {
    echo ""
    echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${GREEN}  $1${NC}"
    echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════════${NC}"
}

print_banner() {
    echo -e "${CYAN}"
    cat << 'EOF'
    ____  _____ ____  _____ ____  
   / __ \/ ___// __ \/ ___// __ \ 
  / / / /\__ \/ / / /\__ \/ /_/ / 
 / /_/ /___/ / /_/ /___/ / ____/  
/_____//____/_____//____/_/       
                                   
Data Science Deployment Tool
EOF
    echo -e "${NC}"
    echo -e "${BOLD}Version: ${VERSION}${NC}"
    echo ""
}

print_usage() {
    print_banner
    cat << EOF
${BOLD}USAGE:${NC}
    ${SCRIPT_NAME} [OPTIONS]

${BOLD}OPTIONS:${NC}
    -r, --repo <URL>          Git repository URL to clone (required)
    -e, --env <PATH>          Conda environment path to use
    -R, --requirements <PATH> Path to requirements.txt file
    -n, --name <NAME>         Service name (default: derived from repo name)
    -m, --main <SCRIPT>       Main Python script to run (default: main.py)
    -a, --args <ARGS>         Arguments to pass to main script
    -l, --log-path <PATH>     Path to log file (default: ./logs/app.log)
    -t, --timeout <SECONDS>   Monitoring timeout in seconds (default: 600)
    -u, --user <USER>         Linux user to run service (default: root)
    -d, --dest <PATH>         Destination directory (default: ${DEFAULT_INSTALL_DIR})
    -p, --conda-profile <PATH> Conda profile script path
    -c, --create-env <NAME>   Create new conda environment with this name
    -v, --venv                Use Python venv instead of conda
    --dry-run                 Show what would be done without executing
    -h, --help                Show this help message
    --version                 Show version

${BOLD}EXAMPLES:${NC}
    # Clone repo and deploy with existing conda env
    ${SCRIPT_NAME} -r https://github.com/user/project -e /root/miniconda3/envs/myenv

    # Clone and create new conda environment
    ${SCRIPT_NAME} -r https://github.com/user/project -c myproject-env

    # Clone with custom requirements file
    ${SCRIPT_NAME} -r https://github.com/user/project -R ./custom-requirements.txt -c myenv

    # Use Python venv instead of conda
    ${SCRIPT_NAME} -r https://github.com/user/project --venv

    # Full example with all options
    ${SCRIPT_NAME} -r https://github.com/user/project \\
        -e /root/miniconda3/envs/prod \\
        -n my-service \\
        -m app.py \\
        -a "--config prod" \\
        -l /var/log/myapp.log \\
        -t 300

${BOLD}WORKFLOW:${NC}
    1. Clone the repository
    2. Set up Python environment (conda/venv)
    3. Install dependencies
    4. Run Linux hardening script (creates runner.py, shell script, systemd service)
    5. Verify service is running and logs are being generated
    6. Report status and exit

${BOLD}NOTES:${NC}
    - Requires sudo privileges for systemd operations
    - If no environment is specified, a new conda env will be created
    - If no requirements.txt is provided, uses repo's requirements.txt or default

EOF
}

check_dependencies() {
    log_step "Step 1/7: Checking Dependencies"
    
    local missing_deps=()
    
    for cmd in git python3 curl; do
        if ! command -v $cmd &> /dev/null; then
            missing_deps+=($cmd)
        else
            log_info "Found: $cmd ($(command -v $cmd))"
        fi
    done
    
    # Check for conda or venv capability
    if [ "$USE_VENV" != "true" ]; then
        if command -v conda &> /dev/null; then
            log_info "Found: conda ($(command -v conda))"
            CONDA_AVAILABLE=true
        else
            log_warning "conda not found, will try to locate it"
            CONDA_AVAILABLE=false
        fi
    fi
    
    # Check systemctl
    if ! command -v systemctl &> /dev/null; then
        log_error "systemctl not found. This tool requires systemd."
        exit 1
    fi
    log_info "Found: systemctl ($(command -v systemctl))"
    
    if [ ${#missing_deps[@]} -ne 0 ]; then
        log_error "Missing dependencies: ${missing_deps[*]}"
        log_error "Please install them and try again."
        exit 1
    fi
    
    log_success "All dependencies satisfied!"
}

find_conda_profile() {
    log_info "Searching for conda profile script..."
    
    local search_paths=(
        "/root/miniconda3/etc/profile.d/conda.sh"
        "/root/anaconda3/etc/profile.d/conda.sh"
        "$HOME/miniconda3/etc/profile.d/conda.sh"
        "$HOME/anaconda3/etc/profile.d/conda.sh"
        "/opt/miniconda3/etc/profile.d/conda.sh"
        "/opt/anaconda3/etc/profile.d/conda.sh"
        "/usr/local/miniconda3/etc/profile.d/conda.sh"
        "/usr/local/anaconda3/etc/profile.d/conda.sh"
    )
    
    for path in "${search_paths[@]}"; do
        if [ -f "$path" ]; then
            log_info "Found conda profile: $path"
            echo "$path"
            return 0
        fi
    done
    
    # Try to find it using locate or find
    if command -v locate &> /dev/null; then
        local found=$(locate -l 1 conda.sh 2>/dev/null | head -1)
        if [ -n "$found" ] && [ -f "$found" ]; then
            log_info "Found conda profile via locate: $found"
            echo "$found"
            return 0
        fi
    fi
    
    return 1
}

clone_repository() {
    log_step "Step 2/7: Cloning Repository"
    
    log_info "Repository: $REPO_URL"
    log_info "Destination: $DEST_DIR"
    
    # Extract repo name from URL
    REPO_NAME=$(basename "$REPO_URL" .git)
    PROJECT_PATH="$DEST_DIR/$REPO_NAME"
    
    log_info "Project name: $REPO_NAME"
    log_info "Project path: $PROJECT_PATH"
    
    # Create destination directory if needed
    if [ ! -d "$DEST_DIR" ]; then
        log_info "Creating destination directory: $DEST_DIR"
        mkdir -p "$DEST_DIR"
    fi
    
    # Clone or update repository
    if [ -d "$PROJECT_PATH" ]; then
        log_warning "Directory already exists: $PROJECT_PATH"
        read -p "Do you want to pull latest changes? (y/n): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            log_info "Pulling latest changes..."
            cd "$PROJECT_PATH"
            git pull
            cd -
        fi
    else
        log_info "Cloning repository..."
        if [ "$DRY_RUN" = "true" ]; then
            log_info "[DRY RUN] Would execute: git clone $REPO_URL $PROJECT_PATH"
        else
            git clone "$REPO_URL" "$PROJECT_PATH"
        fi
    fi
    
    log_success "Repository ready at: $PROJECT_PATH"
}

setup_environment() {
    log_step "Step 3/7: Setting Up Python Environment"
    
    if [ "$USE_VENV" = "true" ]; then
        setup_venv
    else
        setup_conda
    fi
}

setup_venv() {
    log_info "Setting up Python virtual environment..."
    
    VENV_PATH="$PROJECT_PATH/.venv"
    
    if [ -d "$VENV_PATH" ]; then
        log_info "Virtual environment already exists: $VENV_PATH"
    else
        log_info "Creating virtual environment: $VENV_PATH"
        if [ "$DRY_RUN" != "true" ]; then
            python3 -m venv "$VENV_PATH"
        fi
    fi
    
    # Set environment path for later use
    CONDA_ENV_PATH="$VENV_PATH"
    USE_VENV_ACTIVATION=true
    
    log_success "Virtual environment ready: $VENV_PATH"
}

setup_conda() {
    log_info "Setting up Conda environment..."
    
    # Find conda profile if not specified
    if [ -z "$CONDA_PROFILE" ]; then
        CONDA_PROFILE=$(find_conda_profile)
        if [ -z "$CONDA_PROFILE" ]; then
            log_error "Could not find conda profile script."
            log_error "Please specify with -p/--conda-profile option."
            exit 1
        fi
    fi
    
    log_info "Conda profile: $CONDA_PROFILE"
    
    # Source conda
    source "$CONDA_PROFILE"
    
    if [ -n "$CREATE_ENV" ]; then
        # Create new conda environment
        log_info "Creating new conda environment: $CREATE_ENV"
        
        # Determine conda envs directory
        CONDA_BASE=$(conda info --base)
        CONDA_ENV_PATH="$CONDA_BASE/envs/$CREATE_ENV"
        
        if [ -d "$CONDA_ENV_PATH" ]; then
            log_warning "Environment already exists: $CONDA_ENV_PATH"
        else
            log_info "Creating environment..."
            if [ "$DRY_RUN" != "true" ]; then
                conda create -n "$CREATE_ENV" python=3.10 -y
            fi
        fi
        
        log_success "Conda environment ready: $CONDA_ENV_PATH"
    elif [ -n "$CONDA_ENV_PATH" ]; then
        # Use existing conda environment
        if [ ! -d "$CONDA_ENV_PATH" ]; then
            log_error "Conda environment not found: $CONDA_ENV_PATH"
            exit 1
        fi
        log_info "Using existing environment: $CONDA_ENV_PATH"
    else
        # Create default environment based on repo name
        log_info "No environment specified, creating default..."
        CREATE_ENV="${REPO_NAME}-env"
        CONDA_BASE=$(conda info --base)
        CONDA_ENV_PATH="$CONDA_BASE/envs/$CREATE_ENV"
        
        if [ ! -d "$CONDA_ENV_PATH" ]; then
            log_info "Creating environment: $CREATE_ENV"
            if [ "$DRY_RUN" != "true" ]; then
                conda create -n "$CREATE_ENV" python=3.10 -y
            fi
        fi
        
        log_success "Conda environment ready: $CONDA_ENV_PATH"
    fi
}

install_dependencies() {
    log_step "Step 4/7: Installing Dependencies"
    
    # Determine which requirements file to use
    local req_file=""
    
    if [ -n "$REQUIREMENTS_FILE" ]; then
        # User specified requirements file
        if [ -f "$REQUIREMENTS_FILE" ]; then
            req_file="$REQUIREMENTS_FILE"
            log_info "Using specified requirements: $req_file"
        else
            log_error "Requirements file not found: $REQUIREMENTS_FILE"
            exit 1
        fi
    elif [ -f "$PROJECT_PATH/requirements.txt" ]; then
        # Use repo's requirements.txt
        req_file="$PROJECT_PATH/requirements.txt"
        log_info "Using repo's requirements.txt: $req_file"
    else
        # Download default requirements
        log_warning "No requirements.txt found, using default..."
        req_file="$PROJECT_PATH/requirements.txt"
        
        if [ "$DRY_RUN" != "true" ]; then
            log_info "Downloading default requirements from: $DEFAULT_REQUIREMENTS_URL"
            curl -sL "$DEFAULT_REQUIREMENTS_URL" -o "$req_file"
        fi
        log_info "Created default requirements: $req_file"
    fi
    
    # Install dependencies
    log_info "Installing dependencies from: $req_file"
    
    if [ "$DRY_RUN" = "true" ]; then
        log_info "[DRY RUN] Would install dependencies from: $req_file"
        return
    fi
    
    if [ "$USE_VENV" = "true" ]; then
        # Activate venv and install
        source "$CONDA_ENV_PATH/bin/activate"
        pip install --upgrade pip
        pip install -r "$req_file"
        
        # Install ripik_ds_helper
        log_info "Installing ripik_ds_helper..."
        pip install git+https://github.com/ripiktech/ripik_ds_helper.git
        
        # Also install ripikutils for monitoring
        if ! pip show ripikutils &> /dev/null; then
            log_info "Installing ripikutils..."
            pip install ripikutils || log_warning "ripikutils not available, monitoring may be limited"
        fi
    else
        # Use conda environment
        source "$CONDA_PROFILE"
        conda activate "$CONDA_ENV_PATH"
        
        pip install --upgrade pip
        pip install -r "$req_file"
        
        # Install ripik_ds_helper
        log_info "Installing ripik_ds_helper..."
        pip install git+https://github.com/ripiktech/ripik_ds_helper.git
        
        # Also install ripikutils for monitoring
        if ! pip show ripikutils &> /dev/null; then
            log_info "Installing ripikutils..."
            pip install ripikutils || log_warning "ripikutils not available, monitoring may be limited"
        fi
    fi
    
    log_success "Dependencies installed successfully!"
}

run_hardening_script() {
    log_step "Step 5/7: Running Linux Hardening Script"
    
    # Set default service name if not provided
    if [ -z "$SERVICE_NAME" ]; then
        SERVICE_NAME="$REPO_NAME"
    fi
    
    # Set default main script if not provided
    if [ -z "$MAIN_SCRIPT" ]; then
        MAIN_SCRIPT="main.py"
    fi
    
    # Set default log path if not provided
    if [ -z "$LOG_PATH" ]; then
        LOG_PATH="$PROJECT_PATH/logs/app.log"
    fi
    
    # Set default timeout if not provided
    if [ -z "$TIMEOUT" ]; then
        TIMEOUT=600
    fi
    
    # Set default user if not provided
    if [ -z "$RUN_USER" ]; then
        RUN_USER="root"
    fi
    
    log_info "Configuration:"
    log_info "  Project Path: $PROJECT_PATH"
    log_info "  Main Script: $MAIN_SCRIPT"
    log_info "  Script Args: ${SCRIPT_ARGS:-none}"
    log_info "  Log Path: $LOG_PATH"
    log_info "  Service Name: $SERVICE_NAME"
    log_info "  Environment: $CONDA_ENV_PATH"
    log_info "  Timeout: ${TIMEOUT}s"
    log_info "  User: $RUN_USER"
    
    if [ "$DRY_RUN" = "true" ]; then
        log_info "[DRY RUN] Would run hardening script with above configuration"
        return
    fi
    
    # Create logs directory
    mkdir -p "$(dirname "$LOG_PATH")"
    
    # Create the Python script to run hardening
    local setup_script="$PROJECT_PATH/_dsdep_setup.py"
    
    if [ "$USE_VENV" = "true" ]; then
        # For venv, we need a different shell script structure
        cat > "$setup_script" << PYEOF
#!/usr/bin/env python3
import sys
import os
sys.path.insert(0, '$PROJECT_PATH')

# Import from installed package
from DsHelper import HardeningConfig, setup_linux_hardening

config = HardeningConfig(
    project_path="$PROJECT_PATH",
    main_script="$MAIN_SCRIPT",
    script_args="$SCRIPT_ARGS",
    log_file_path="$LOG_PATH",
    service_name="$SERVICE_NAME",
    conda_env_path="$CONDA_ENV_PATH",
    conda_profile_path="$CONDA_ENV_PATH/bin/activate",
    time_interval=$TIMEOUT,
    user="$RUN_USER"
)

# Override shell script creation for venv
def create_venv_shell_script(config):
    shell_content = f'''#!/bin/bash
cd {config.project_path} || exit 1
source {config.conda_env_path}/bin/activate
python runner.py
'''
    import stat
    shell_path = os.path.join(config.project_path, f"{config.service_name}.sh")
    with open(shell_path, "w") as f:
        f.write(shell_content)
    st = os.stat(shell_path)
    os.chmod(shell_path, st.st_mode | stat.S_IEXEC)
    return shell_path

# Monkey-patch for venv support
import DsHelper.linux_hardening as lh
lh.create_shell_script = create_venv_shell_script

result = setup_linux_hardening(config)
print(result)
sys.exit(0 if result['status'] else 1)
PYEOF
    else
        # For conda environments
        cat > "$setup_script" << PYEOF
#!/usr/bin/env python3
import sys
sys.path.insert(0, '$PROJECT_PATH')

# Import from installed package
from DsHelper import HardeningConfig, setup_linux_hardening

config = HardeningConfig(
    project_path="$PROJECT_PATH",
    main_script="$MAIN_SCRIPT",
    script_args="$SCRIPT_ARGS",
    log_file_path="$LOG_PATH",
    service_name="$SERVICE_NAME",
    conda_env_path="$CONDA_ENV_PATH",
    conda_profile_path="$CONDA_PROFILE",
    time_interval=$TIMEOUT,
    user="$RUN_USER"
)

result = setup_linux_hardening(config)
print(result)
sys.exit(0 if result['status'] else 1)
PYEOF
    fi
    
    # Run the setup script
    if [ "$USE_VENV" = "true" ]; then
        source "$CONDA_ENV_PATH/bin/activate"
        python3 "$setup_script"
    else
        source "$CONDA_PROFILE"
        conda activate "$CONDA_ENV_PATH"
        python3 "$setup_script"
    fi
    
    # Clean up setup script
    rm -f "$setup_script"
    
    log_success "Hardening script completed!"
}

verify_deployment() {
    log_step "Step 6/7: Verifying Deployment"
    
    if [ "$DRY_RUN" = "true" ]; then
        log_info "[DRY RUN] Would verify deployment"
        return
    fi
    
    local all_ok=true
    
    # Check 1: Files created
    log_info "Checking created files..."
    
    local files_to_check=(
        "$PROJECT_PATH/runner.py"
        "$PROJECT_PATH/${SERVICE_NAME}.sh"
        "/etc/systemd/system/${SERVICE_NAME}.service"
    )
    
    for file in "${files_to_check[@]}"; do
        if [ -f "$file" ]; then
            log_success "  Found: $file"
        else
            log_error "  Missing: $file"
            all_ok=false
        fi
    done
    
    # Check 2: Service is running
    log_info "Checking service status..."
    sleep 3  # Give service time to start
    
    if systemctl is-active --quiet "${SERVICE_NAME}.service"; then
        log_success "  Service is running!"
    else
        log_warning "  Service is not running (may still be starting)"
        log_info "  Status:"
        systemctl status "${SERVICE_NAME}.service" --no-pager 2>&1 | head -20 || true
    fi
    
    # Check 3: Service is enabled
    log_info "Checking service is enabled..."
    
    if systemctl is-enabled --quiet "${SERVICE_NAME}.service"; then
        log_success "  Service is enabled (will start on boot)"
    else
        log_warning "  Service is not enabled"
    fi
    
    # Check 4: Logs directory exists
    log_info "Checking logs directory..."
    
    local log_dir=$(dirname "$LOG_PATH")
    if [ -d "$log_dir" ]; then
        log_success "  Logs directory exists: $log_dir"
    else
        log_warning "  Logs directory not found: $log_dir"
    fi
    
    # Check 5: Wait and check for log file
    log_info "Waiting for log file to be created (10 seconds)..."
    sleep 10
    
    if [ -f "$LOG_PATH" ]; then
        log_success "  Log file exists: $LOG_PATH"
        log_info "  Recent log entries:"
        tail -5 "$LOG_PATH" 2>/dev/null | while read line; do
            echo "    $line"
        done
    else
        log_warning "  Log file not yet created: $LOG_PATH"
        log_info "  (This may be normal if main script hasn't written yet)"
    fi
    
    # Check 6: Check journalctl for errors
    log_info "Checking service logs for errors..."
    
    local error_count=$(journalctl -u "${SERVICE_NAME}.service" -n 50 --no-pager 2>/dev/null | grep -ci "error\|exception\|failed" || echo "0")
    
    if [ "$error_count" -eq 0 ]; then
        log_success "  No errors found in service logs"
    else
        log_warning "  Found $error_count potential issues in logs"
        log_info "  Recent service logs:"
        journalctl -u "${SERVICE_NAME}.service" -n 10 --no-pager 2>/dev/null | while read line; do
            echo "    $line"
        done
    fi
    
    echo ""
    if [ "$all_ok" = true ]; then
        log_success "All verification checks passed!"
    else
        log_warning "Some verification checks had warnings"
    fi
}

print_summary() {
    log_step "Step 7/7: Deployment Summary"
    
    echo -e "${BOLD}Deployment completed successfully!${NC}"
    echo ""
    echo -e "${BOLD}Project Details:${NC}"
    echo "  Repository: $REPO_URL"
    echo "  Location: $PROJECT_PATH"
    echo "  Service: ${SERVICE_NAME}.service"
    echo "  Environment: $CONDA_ENV_PATH"
    echo ""
    echo -e "${BOLD}Created Files:${NC}"
    echo "  - $PROJECT_PATH/runner.py"
    echo "  - $PROJECT_PATH/${SERVICE_NAME}.sh"
    echo "  - /etc/systemd/system/${SERVICE_NAME}.service"
    echo ""
    echo -e "${BOLD}Useful Commands:${NC}"
    echo -e "  ${CYAN}View status:${NC}   sudo systemctl status $SERVICE_NAME"
    echo -e "  ${CYAN}View logs:${NC}     sudo journalctl -u $SERVICE_NAME -f"
    echo -e "  ${CYAN}Stop service:${NC}  sudo systemctl stop $SERVICE_NAME"
    echo -e "  ${CYAN}Start service:${NC} sudo systemctl start $SERVICE_NAME"
    echo -e "  ${CYAN}Restart:${NC}       sudo systemctl restart $SERVICE_NAME"
    echo -e "  ${CYAN}Disable:${NC}       sudo systemctl disable $SERVICE_NAME"
    echo ""
    echo -e "  ${CYAN}App logs:${NC}      tail -f $LOG_PATH"
    echo ""
    log_success "Deployment complete! Service is running."
}

# =============================================================================
# Main
# =============================================================================

main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -r|--repo)
                REPO_URL="$2"
                shift 2
                ;;
            -e|--env)
                CONDA_ENV_PATH="$2"
                shift 2
                ;;
            -R|--requirements)
                REQUIREMENTS_FILE="$2"
                shift 2
                ;;
            -n|--name)
                SERVICE_NAME="$2"
                shift 2
                ;;
            -m|--main)
                MAIN_SCRIPT="$2"
                shift 2
                ;;
            -a|--args)
                SCRIPT_ARGS="$2"
                shift 2
                ;;
            -l|--log-path)
                LOG_PATH="$2"
                shift 2
                ;;
            -t|--timeout)
                TIMEOUT="$2"
                shift 2
                ;;
            -u|--user)
                RUN_USER="$2"
                shift 2
                ;;
            -d|--dest)
                DEST_DIR="$2"
                shift 2
                ;;
            -p|--conda-profile)
                CONDA_PROFILE="$2"
                shift 2
                ;;
            -c|--create-env)
                CREATE_ENV="$2"
                shift 2
                ;;
            -v|--venv)
                USE_VENV="true"
                shift
                ;;
            --dry-run)
                DRY_RUN="true"
                shift
                ;;
            -h|--help)
                print_usage
                exit 0
                ;;
            --version)
                echo "dsdep version $VERSION"
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                print_usage
                exit 1
                ;;
        esac
    done
    
    # Set default destination directory
    if [ -z "$DEST_DIR" ]; then
        DEST_DIR="$DEFAULT_INSTALL_DIR"
    fi
    
    # Validate required arguments
    if [ -z "$REPO_URL" ]; then
        log_error "Repository URL is required (-r/--repo)"
        echo ""
        print_usage
        exit 1
    fi
    
    # Print banner and start
    print_banner
    
    if [ "$DRY_RUN" = "true" ]; then
        log_warning "DRY RUN MODE - No changes will be made"
        echo ""
    fi
    
    # Check if running as root (required for systemd)
    if [ "$EUID" -ne 0 ] && [ "$DRY_RUN" != "true" ]; then
        log_warning "This script should be run with sudo for systemd operations"
        read -p "Continue anyway? (y/n): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi
    
    # Execute deployment steps
    check_dependencies
    clone_repository
    setup_environment
    install_dependencies
    run_hardening_script
    verify_deployment
    print_summary
    
    exit 0
}

main "$@"
